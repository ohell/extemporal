/*
	Copyright Amit Jain 2013

	This file is part of extemporal encryption scheme implementation.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Affero General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
package net.extemporal;

import java.nio.ByteBuffer;

/**
 * This interface should be implemented to provide storage/retrieval/transmission facilities to the {@link Engine}.
 * Note that there are no security requirements imposed by this interface. All that is expected is that the shared
 * secrets (if any) and the temporary key store should remain private to the device/user. <br/>
 * It is up to the implementation to decide how to achieve this. The two test platforms do not take any security
 * precautions at all, though this is not advisable for a production platform. <br/>
 * At the very least, the shared secrets must be kept private, maybe behind a password.
 */
public interface Platform {
	/**
	 *
	 * @param endpoint the other party that shares the same secret.
	 * @param platformContext context object passed to the {@link Engine}. Can be used to enforce a verification scheme
	 * @return a common shared secret with the other party, null if no secret is shared
	 */
	abstract byte[] retrieveSharedSecret(String endpoint, Object platformContext);

	/**
	 *
	 * @param platformContext context object passed to the {@link Engine}
	 * @param key the key object to be stored.
	 * @param endpoint recipient of the message, for which the key is being used. Will be passed again during retrieval.
	 * @return a reference value that can be used to retrieve the key
	 *
	 * Note that the security of the key store is entirely up to the {@link Platform} implementation. As the name
	 * indicates, keys are not expected to be stored for a long time - only until the endpoint responds to our message.
	 * So, it is fine to implement a timeout policy suitable for the messaging domain. If a stored key can't be
	 * retrieved, the {@link Engine} will simply not respond to the received message.
	 */
	abstract int temporarilyStoreKey(Object platformContext, TemporalKey key, String endpoint);

	/**
	 *
	 * @param platformContext context object passed to the {@link Engine}
	 * @param reference retrieval reference generated by this.temporarilyStoreKey()
	 * @param endpoint recipient of the message, for which the key was used. Same value was passed during storage.
	 * @return the retrieved key object
	 *
	 * Return a key stored previously. AIf a stored key can't be  retrieved, the {@link Engine} will simply not respond
	 * to the received message, and return a failure code from {@link Engine}.processReceivedEnvelope()
	 */
	abstract TemporalKey retrieveKey(Object platformContext, int reference, String endpoint);

	/**
	 *
	 * @param platformContext context object passed to the {@link Engine}
	 * @param reference retrieval reference generated by this.temporarilyStoreKey()
	 * @param endpoint recipient of the message, for which the key was used. Same value was passed during storage.
	 * @return true if the key was found (and destroyed).
	 *
	 * The stored key will not be used anymore. All references to it should be dropped now.
	 */
	abstract boolean destroyKey(Object platformContext, int reference, String endpoint);

	/**
	 *
	 * @param from sender of the message
	 * @param commType type of the message, according to the header. See {@link Engine}.flag* constants
	 * @param wrapper use this to change the platformContext object, if required. This is the last function guaranteed
	 *                to be called synchronously after the {@link Engine}.processReceivedEnvelope() is used to notify
	 *                the engine of a new received message. See EmailTestPlatform in test sources for an example.
	 * @param verifiable whether the received message has the sender's authentication data in the header.
	 * @param ourRefIfAny key store reference, set in case this message is an acknowledgement of a new message from us.
	 * @param theirRefIfAny sender's reference. Included for completeness.
	 * @return whether the {@link Engine should proceed with decrypting this message}
	 *
	 * Implement this function to decide when to process a received encrypted message.
	 */
	abstract boolean openReceivedEnvelope(String from, int commType, MutablePlatformContext wrapper, boolean verifiable, Integer ourRefIfAny, Integer theirRefIfAny);

	/**
	 *
	 * @param platformContext context object passed to the {@link Engine}, and possibly changed by openReceivedEnvelope()
	 * @param endpoint message destination
	 * @param messageBytes message content.
	 * @return whether the bytes were successfully transmitted.
	 *
	 * Send the message. Note that if messageBytes are encoded as part of the final message, the encoding *must* be
	 * loss-less, i.e. UTF-8, UTF-16 etc are no good because some byte sequences do not parse into valid characters.
	 */
	abstract boolean transmitBytes(Object platformContext, String endpoint, ByteBuffer messageBytes);

	/**
	 *
	 * @param platformContext context object passed to the {@link Engine}, and possibly changed by openReceivedEnvelope()
	 * @param endpoint message sender
	 * @param messagePlainBytes decrypted message content.
	 * @return whether the message was successfully handled.
	 *
	 * Final method called by the {@link Engine} on the recipient platform. Passes the decrypted message content to this
	 * platform.
	 */
	abstract boolean handleReceivedMessage(Object platformContext, String endpoint, ByteBuffer messagePlainBytes);

	/**
	 *
	 * @param function a task to execute asynchronously
	 *
	 * Called by the engine to execute long-running tasks (e.g. sending of a message)
	 */
	abstract void executeAsynchronously(Runnable function);

	/**
	 *
	 * @return a character identifying this platform. Included in the header, though not currently used for any validation.
	 */
	abstract byte getTypeIdentifier();

	/**
	 *
	 * @param e exception object
	 *
	 * Handle any exceptions thrown while processing a message
	 */
	abstract void processException(Exception e);

	/**
	 * The key objects used to encrypt/decrypt messages.
	 * bytes are the key data, while createdTime is the system time when this key was generated.
	 * createdTime is included as part of message verification headers, used to thwart MITM attacks.
	 */
	public static class TemporalKey {
		public final byte[] bytes;
		public final int createdTime;

		TemporalKey(byte[] key_, int createdTime_)
		{
			bytes = key_;
			createdTime = createdTime_;
		}
	}

	public static class MutablePlatformContext {
		MutablePlatformContext(Object pc)
		{
			platformContext = pc;
		}
		public Object platformContext;
	}
}
